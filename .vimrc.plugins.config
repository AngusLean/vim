

"ctrlpvim/ctrlp.vim {{{
 let g:ctrlp_working_path_mode = ''
 let g:ctrlp_match_window = 'bottom,order:ttb,min:1,max:10,results:10'
 let g:ctrlp_follow_symlinks = 2
 let g:ctrlp_max_files = 0 " Unset cap of 10,000 files so we find everything

 set wildignore+=*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux
 set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe  " Windows

 "let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
 let g:ctrlp_custom_ignore = {
   \ 'dir':  '\v[\/]\.(git|hg|svn)$',
   \ 'file': '\v\.(exe|o|so|dll)$',
   \ 'link': 'some_bad_symbolic_links'
   \ }
" nnoremap <unique> <leader>bs :CtrlPBuffer<CR>
" nnoremap <unique> <c-s-p> :CtrlPBuffer<CR>

"}}}
"Yggdroot/LeaderF  ctrlp replacement {{{
let g:Lf_ShortcutF = '<C-P>'
let g:Lf_WildIgnore = {
        \ 'dir': ['.svn','.git','node_modules','.exvim*'],
        \ 'file': ['*.sw?','~$*','*.bak','*.exe','*.dll','*.o','*.so','*.py[co]']
        \}

"}}}

"tpope/vim-surround {{{
xmap s <Plug>VSurround
"}}}

"itchyny/lightline.vim {{{
  let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ 'active': {
      \   'left': [ [ 'mode'],['filename'],
      \             [ 'syntastic','readonly', 'asyncrun' ] ]
      \ },
      \ 'component': {
      \   'readonly': '%{&filetype=="help"?"":&readonly?"⭤":""}'
      \ },
      \ 'component_function': {
      \   'asyncrun': 'LightLineAsync',
      \   'syntastic': 'ALEGetStatusLine'
      \ },
      \ 'component_visible_condition': {
      \   'readonly': '(&filetype!="help"&& &readonly)'
      \ },
      \ 'separator': { 'left': "\ue0b0", 'right': "\u2b82" },
      \ 'subseparator': { 'left': " >", 'right': "|" }
      \ }

 "    \ 'component_expand': {
 "    \   'syntastic': 'SyntasticStatuslineFlag',
 "    \ },
function! LightLineAsync()
  if g:asyncrun_status == "running"
    return "asyn-running"
  elseif g:asyncrun_status == "success"
    return "asyn-exit"
  elseif g:asyncrun_status == "failure"
    return "asyn-fail"
  else
    return ""
endfunction
"}}}

"troydm/easytree.vim {{{
nnoremap <F3> :EasyTreeToggle<CR>
let g:easytree_ignore_dirs = ['node_modules','__pycache__','.exvim.*']
let g:easytree_ignore_files = ['*.swp','*.tmp','*.pyc','*.exe','*.o','*.dll','*.ico']
"}}}

" nerdcommenter: invoke by <leader>c<space>, <leader>cl, <leader>cu, <F11> or <C-F11>
"{{{
let g:NERDSpaceDelims = 1
let g:NERDRemoveExtraSpaces = 1
let g:NERDCustomDelimiters = {
            \ 'vimentry': { 'left': '--' },
            \ }
" map <unique> <C-/> <Plug>NERDCommenterAlignBoth
" map <unique> <C-F11> <Plug>NERDCommenterUncomment

"}}}


"scrooloose/syntastic {{{
"let g:syntastic_javascript_checkers = ['eslint']
"set statusline+=%#warningmsg#
"set statusline+=%{SyntasticStatuslineFlag()}
"set statusline+=%*

"let g:syntastic_always_populate_loc_list = 1
"let g:syntastic_auto_loc_list = 1
"let g:syntastic_check_on_open = 0
"let g:syntastic_check_on_wq = 0
"this will make html file by Angular.js ignore errors
"let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"]

"}}}


"w0rp/ale {{{
let g:ale_linters = {
\   'javascript': ['eslint'],
\   'c':['gcc']
\}
let g:ale_statusline_format = ['%d error(s)', '%d warning(s)', 'OK']
nmap <silent> <C-up> <Plug>(ale_previous_wrap)
nmap <silent> <C-down> <Plug>(ale_next_wrap)
"}}}




"vim-scripts/LargeFile {{{
let g:LargeFile= 5 " files >= 5MB will use LargeFile rules

"}}}


"emmet-vim {{{
let g:user_emmet_install_global = 0
autocmd FileType html,css,jsp EmmetInstall

"}}}


"godlygeek/tabular {{{
nnoremap <silent> <leader>= :call g:Tabular(1)<CR>
xnoremap <silent> <leader>= :call g:Tabular(0)<CR>
function! g:Tabular(ignore_range) range
   let c = getchar()
   let c = nr2char(c)
    if a:ignore_range == 0
        exec printf('%d,%dTabularize /%s', a:firstline, a:lastline, c)
    else
        exec printf('Tabularize /%s', c)
    endif
endfunction
"}}}


"plasticboy/vim-markdown {{{
let g:vim_markdown_initial_foldlevel=9999

"}}}


"ntpeters/vim-better-whitespace {{{
autocmd BufWritePre * StripWhitespace
"}}}


"othree/yajs.vim {{{
let g:smc = 100
"}}}


"Shougo/vimproc.vim {{{
set rtp += "/vimfiles/plugged/vimproc.vim"

"}}}


"Shougo/unite.vim neomru.vim {{{

function! DoUniteFuzzyLine()
    call unite#custom#source('line', 'sorters', 'sorter_rank')
    call unite#custom#source('line', 'matchers', 'matcher_fuzzy')
    exec "Unite -buffer-name=line line"
endfunction

if executable('ag')
  let g:unite_source_rec_async_command =
            \ ['ag', '--follow', '--nocolor', '--nogroup',
    \  '--hidden', '-g','-l',  '']

  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts = '--nocolor --nogroup --hidden --ignore-case --ignore tags'
    \. ' --ignore node_modules  --ignore .git --ignore doc'
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ack-grep')
  let g:unite_source_grep_command = 'ack-grep'
  let g:unite_source_grep_default_opts =
              \ '--no-heading --no-color -a -H'
  let g:unite_source_grep_recursive_opt = ''
elseif executable('pt')
  let g:unite_source_grep_command = 'pt'
  let g:unite_source_grep_default_opts = '--nogroup --nocolor'
  let g:unite_source_grep_recursive_opt = ''
  let g:unite_source_grep_encoding = 'utf-8'
endif

" call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#custom#source('file,file_rec/async,file_rec,file_mru',
        \ 'ignore_pattern', join([
        \ '\.swp', '\.swo', '\~$',
        \ '\.git/', '\.svn/', '\.hg/',
        \ '^tags$', '\.taghl$','test/','doc/','build/','\.exvim.*/',
        \ '\.ropeproject/', '\.pbxproj$', '\.xcodeproj', '\.vcproj',
        \ 'node_modules/', 'bower_components/', 'typings/', 'libs/', 'log/', 'tmp/', 'obj/',
        \ '/vendor/gems/', '/vendor/cache/', '\.bundle/', '\.sass-cache/',
        \ '/tmp/cache/assets/.*/sprockets/', '/tmp/cache/assets/.*/sass/',
        \ 'thirdparty/', 'Debug/', 'Release/', 'build/', 'dist/',
        \ 'web/static/components/', 'web/static/external/', 'web/static/images/',
        \ '\.pyc$', 'pb2\.py$', '\.class$', '\.jar$', '\.min\.js$',
        \ '\.jpg$', '\.jpeg$', '\.bmp$', '\.png$', '\.gif$',
        \ '\.o$', '\.out$', '\.obj$', '\.rbc$', '\.rbo$', '\.gem$',
        \ '\.zip$', '\.tar\.gz$', '\.tar\.bz2$', '\.rar$', '\.tar\.xz$'
        \ ], '\|'))
call unite#custom#profile('default', 'context', {
    \   'start_insert': 1,
    \   'winheight': 10,
    \   'direction': 'botright',
    \ })

nnoremap <silent><leader>l :call g:DoUniteFuzzyLine()<CR>
"nnoremap <c-e> :Unite -start-insert -buffer -auto-resize file_mru file_rec/async  file <CR>
" nnoremap <c-s-p> :Unite -start-insert -auto-resize file file_rec/async file_mru <CR>
nmap <leader>n :Unite file/new:.<CR>
"nmap <leader>N :Unite dic/new:.<CR>
nnoremap <c-f> :Unite grep:.<CR>
"}}}


"neocomplete {{{
if count(g:exvim_plug_groups , 'neocomplete')
 " Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
    " Disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 2
    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
        \ 'default' : '',
        \ 'arduino' : $VIM.'/vimfiles/requirefile/dict/arduino.dict',
        \ 'c' : $VIM.'/vimfiles/requirefile/dict/c.dict',
        \ 'cpp' : $VIM.'/vimfiles/requirefile/dict/cpp.dict',
        \ 'css' : $VIM.'/vimfiles/requirefile/dict/css.dict',
        \ 'java' : $VIM.'/vimfiles/requirefile/dict/java.dict',
        \ 'javascript' : $VIM.'/vimfiles/requirefile/dict/javascript.dict',
        \ 'php' : $VIM.'/vimfiles/requirefile/dict/php.dict',
        \ 'vim' : $VIM.'/vimfiles/requirefile/dict/vim.dict',
        \ 'matlab' : $VIM.'/vimfiles/requirefile/dict/matlab.dict',
    \ }

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
    return neocomplete#close_popup() . "\<CR>"
    " For no inserting <CR> key.
    return pumvisible() ? neocomplete#close_popup() : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplete#close_popup()
    inoremap <expr><C-e>  neocomplete#cancel_popup()
    " Close popup by <Space>.
    inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

    " For cursor moving in insert mode(Not recommended)
    inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
    inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
    inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
    inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
    " Or set this.
    let g:neocomplete#enable_cursor_hold_i = 1
    " Or set this.
    let g:neocomplete#enable_insert_char_pre = 1

    " AutoComplPop like behavior.
    " let g:neocomplete#enable_auto_select = 1

    " Shell like behavior(not recommended).
    "set completeopt+=longest
    "let g:neocomplete#enable_auto_select = 1
    "let g:neocomplete#disable_auto_complete = 1
    "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    " if !exists('g:neocomplete#sources#omni#input_patterns')
    " let g:neocomplete#sources#omni#input_patterns = {}
    " endif
    "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

"}}}
"Valloric/YouCompleteMe {{{
elseif count(g:exvim_plug_groups , 'YouCompleteMe')
    let g:ycm_confirm_extra_conf=0   "设置加载py文件不提示
    "设置离开插入模式自动关闭预览窗口
    let g:ycm_autoclose_preview_window_after_insertion=1
    "设置选择预览数据过后自动关闭
    let g:ycm_autoclose_preview_window_after_completion =1
    if g:iswindows
        let g:ycm_python_binary_path="C:/Program Files/Python35/python.exe"
        let g:ycm_global_ycm_extra_conf = 'C:/Yvim/vimfiles/requirefile/windows/.ycm_extra_conf.py'
    else
        let g:ycm_python_binary_path="/usr/bin/python3.5"
        let g:ycm_global_ycm_extra_conf = '~/software/exvim1/vimfiles/requirefile/linux/.ycm_extra_conf.py'
    endif
    let g:ycm_filetype_whitelist = { 'c': 1 ,'cpp' : 1,'h':1,'javascript':1,'html':1,'htm':1,'python':1 }

    " YCM 集成 OmniCppComplete 补全引擎
    inoremap <leader>; <C-x><C-o>
    " 设置转到定义处的快捷键为ALT + G，
    "nmap <M-g> :YcmCompleter GoToDefinitionElseDeclaration <C-R>=expand("<cword>")<CR><CR>
    nnoremap <M-g> :YcmCompleter GoTo <CR>
    "命名模式下ycm映射到YcmCompleter
    "cmap ycm YcmCompleter
    autocmd FileType javascript nnoremap <M-F7> :YcmCompleter GoToReferences<cr>
    autocmd FileType javascript nnoremap <S-F6> :YcmCompleter RefactorRename<space>
    " 补全功能在注释中同样有效
    let g:ycm_complete_in_comments=1
    " 开启标签补全
    " let g:ycm_collect_identifiers_from_tags_files = 1
    " set tags+='e:\.symbs\cpp_src\tags' "C++标准库的tags
    " 从第一个键入字符就开始罗列匹配项
    let g:ycm_min_num_of_chars_for_completion=2
    " 离开插入模式后自动关闭预览窗口
    autocmd InsertLeave * if pumvisible() == 0|pclose|endif
    " 禁止缓存匹配项，每次都重新生成匹配项
    "let g:ycm_cache_omnifunc = 1
    " 语法关键字补全
    let g:ycm_seed_identifiers_with_syntax=1
    " 修改对C函数的补全快捷键，默认是CTRL + space，修改为ALT + ;
    let g:ycm_key_invoke_completion = '<M-;>'
    " 回车即选中当前项
    inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"
endif
"}}}


"maksimr/vim-jsbeautify {{{

" or
autocmd FileType javascript noremap <buffer>  <leader>f :call JsBeautify()<cr>
" for json
autocmd FileType json noremap <buffer> <leader>f :call JsonBeautify()<cr>
" for html
autocmd FileType html noremap <buffer> <leader>f :call HtmlBeautify()<cr>
" for css or scss
autocmd FileType css noremap <buffer> <leader>f :call CSSBeautify()<cr>
autocmd FileType javascript vnoremap <buffer>  <leader>f :call RangeJsBeautify()<cr>
autocmd FileType json vnoremap <buffer> <leader>f :call RangeJsonBeautify()<cr>
autocmd FileType html vnoremap <buffer> <leader>f :call RangeHtmlBeautify()<cr>
autocmd FileType css vnoremap <buffer> <leader>f :call RangeCSSBeautify()<cr>

"}}}

"skywind3000/asyncrun.vim {{{
autocmd FileType python nnoremap <F9> :AsyncRun python %:p<cr>
if g:islinux
  autocmd FileType html nnoremap <F9> :AsyncRun firefox %<cr>
else
  autocmd FileType html nnoremap <F9> :AsyncRun D:\DevelopTool\ffdevelop\firefox.exe %<cr>
endif
nnoremap <c-F9> :AsyncStop <cr>
noremap <F10> :call asyncrun#quickfix_toggle(8)<cr>


"}}}


"SirVer/ultisnips {{{
" UltiSnips 的 tab 键与 YCM 冲突，重新设定
let g:UltiSnipsExpandTrigger="<leader><tab>"

let g:UltiSnipsExpandTrigger="<c-j>"
" let g:UltiSnipsExpandTrigger="<c-y>"
let g:UltiSnipsJumpForwardTrigger="<leader><tab>"
let g:UltiSnipsJumpBackwardTrigger="<leader><s-tab>"

"}}}





if g:islinux
    set guifont=Source\ Code\ Pro\ Bold\ 11
endif
