
"Yggdroot/LeaderF  ctrlp replacement {{{
let g:Lf_ShortcutF = '<C-P>'
let g:Lf_WildIgnore = {
        \ 'dir': ['.svn','.git','node_modules','.exvim*'],
        \ 'file': ['*.sw?','~$*','*.bak','*.exe','*.dll','*.o','*.so','*.py[co]']
        \}

"}}}

"tpope/vim-surround {{{
xmap s <Plug>VSurround
"}}}

"itchyny/lightline.vim {{{
  let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ 'active': {
      \   'left': [ [ 'mode'],['filename'],
      \             [ 'syntastic','readonly', 'asyncrun' ] ]
      \ },
      \ 'component': {
      \   'readonly': '%{&filetype=="help"?"":&readonly?"⭤":""}'
      \ },
      \ 'component_function': {
      \   'asyncrun': 'LightLineAsync',
      \   'syntastic': 'ALEGetStatusLine'
      \ },
      \ 'component_visible_condition': {
      \   'readonly': '(&filetype!="help"&& &readonly)'
      \ },
      \ 'separator': { 'left': "\ue0b0", 'right': "\u2b82" },
      \ 'subseparator': { 'left': " >", 'right': "|" }
      \ }

 "    \ 'component_expand': {
 "    \   'syntastic': 'SyntasticStatuslineFlag',
 "    \ },
function! LightLineAsync()
  if g:asyncrun_status == "running"
    return "asyn-running"
  elseif g:asyncrun_status == "success"
    return "asyn-exit"
  elseif g:asyncrun_status == "failure"
    return "asyn-fail"
  else
    return ""
endfunction
"}}}

"scrooloose/nerdtree {{{
map <F3> :NERDTreeToggle<CR>
"}}}


"Chiel92/vim-autoformat {{{
let g:formatdef_autopep8 = "'autopep8 - --range '.a:firstline.' '.a:lastline"
let g:formatters_python = ['autopep8']
"}}}


" nerdcommenter: invoke by <leader>c<space>, <leader>cl, <leader>cu, <F11> or <C-F11>
"{{{
"let g:NERDCreateDefaultMappings = 0
let g:NERDSpaceDelims = 1
let g:NERDRemoveExtraSpaces = 1
let g:NERDCustomDelimiters = {
            \ 'vimentry': { 'left': '--' },
            \ }

nnoremap <leader>cc :NERDComToggleComment<CR>

"}}}


"scrooloose/syntastic {{{
let g:syntastic_javascript_checkers = ['eslint']
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
"let g:syntastic_always_populate_loc_list = 1
"let g:syntastic_auto_loc_list = 1
"let g:syntastic_check_on_open = 0
"let g:syntastic_check_on_wq = 0
"this will make html file by Angular.js ignore errors
"let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"]

"}}}


"w0rp/ale {{{
let g:ale_linters = {
\   'javascript': ['eslint'],
\   'c':['gcc'],
\   'python':['pylint'],
\}
let g:ale_statusline_format = ['%d error(s)', '%d warning(s)', 'OK']
"let g:ale_lint_on_text_changed = 0
"let g:ale_lint_on_enter = 0
"let g_ale_lint_on_save=1
nmap <silent> <C-up> <Plug>(ale_previous_wrap)
nmap <silent> <C-down> <Plug>(ale_next_wrap)
"}}}


"dyng/ctrlsf.vim {{{
let g:ctrlsf_case_sensitive = 'no'
let g:ctrlsf_auto_close = 1
" 高亮匹配行: o->打开的目标文件;p->预览文件
let g:ctrlsf_selected_line_hl = 'op'
" 默认搜索路径, 设置为project则从本文件的工程目录搜索
" let g:ctrlsf_default_root = 'project+wf'
" 工程目录的顶级文件夹
" let g:ctrlsf_vcs_folder = ['.exvim', '.git', '.hg', '.svn', '.bzr', '_darcs']
" make result windows compact
let g:ctrlsf_indent = 2
let g:ctrlsf_regex_pattern = 1
vmap     <C-F>f <Plug>CtrlSFVwordPath
nmap     <C-F>n <Plug>CtrlSFCwordPath
nmap     <C-S-F> <Plug>CtrlSFPwordPath
" nmap     <C-F>f <Plug>CtrlSFPrompt
" vmap     <C-F>F <Plug>CtrlSFVwordExec
" nnoremap <C-F>o :CtrlSFOpen<CR>
" nnoremap <C-F>t :CtrlSFToggle<CR>
" inoremap <C-F>t <Esc>:CtrlSFToggle<CR>
"}}}

"kristijanhusak/vim-multiple-cursors{{{
" let g:multi_cursor_use_default_mapping = 0
" let g:multi_cursor_start_word_key = '<C-j>'
" let g:multi_cursor_next_key = '<C-j>'
" let g:multi_cursor_prev_key = '<C-k>'
" let g:multi_cursor_skip_key = '<C-x>'
" let g:multi_cursor_quit_key = '<ESC>'
" Called once right before you start selecting multiple cursors
function! Multiple_cursors_before()
  if exists(':NeoCompleteLock')==2
    exe 'NeoCompleteLock'
  endif
endfunction

" Called once only when the multiple selection is canceled (default <Esc>)
function! Multiple_cursors_after()
  if exists(':NeoCompleteUnlock')==2
    exe 'NeoCompleteUnlock'
  endif
endfunction
"}}}


"vim-scripts/LargeFile {{{
let g:LargeFile= 5 " files >= 5MB will use LargeFile rules
"}}}

"emmet-vim {{{
let g:user_emmet_install_global = 0
autocmd FileType html,vue,css,jsp EmmetInstall
let g:user_emmet_settings={
\   'vue':{
\       'extends': 'html,javascript,css',
\   }
\}
"}}}

"godlygeek/tabular {{{
nnoremap <silent> <leader>= :call g:Tabular(1)<CR>
xnoremap <silent> <leader>= :call g:Tabular(0)<CR>
function! g:Tabular(ignore_range) range
   let c = getchar()
   let c = nr2char(c)
    if a:ignore_range == 0
        exec printf('%d,%dTabularize /%s', a:firstline, a:lastline, c)
    else
        exec printf('Tabularize /%s', c)
    endif
endfunction
"}}}


"plasticboy/vim-markdown {{{
let g:vim_markdown_initial_foldlevel=9999

"}}}

"ntpeters/vim-better-whitespace {{{
autocmd BufWritePre * StripWhitespace
"}}}

"othree/yajs.vim {{{
let g:smc = 100
"}}}

"neocomplete {{{
if count(g:exvim_plug_groups , 'neocomplete')
 " Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
    " Disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 2
    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
        \ 'default' : '',
        \ 'arduino' : $VIM.'/vimfiles/requirefile/dict/arduino.dict',
        \ 'c' : $VIM.'/vimfiles/requirefile/dict/c.dict',
        \ 'cpp' : $VIM.'/vimfiles/requirefile/dict/cpp.dict',
        \ 'css' : $VIM.'/vimfiles/requirefile/dict/css.dict',
        \ 'java' : $VIM.'/vimfiles/requirefile/dict/java.dict',
        \ 'javascript' : $VIM.'/vimfiles/requirefile/dict/javascript.dict',
        \ 'php' : $VIM.'/vimfiles/requirefile/dict/php.dict',
        \ 'vim' : $VIM.'/vimfiles/requirefile/dict/vim.dict',
        \ 'matlab' : $VIM.'/vimfiles/requirefile/dict/matlab.dict',
    \ }

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.

    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    "inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    "inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    "inoremap <expr><C-y>  neocomplete#close_popup()
    "inoremap <expr><C-e>  neocomplete#cancel_popup()
    " Close popup by <Space>.
    "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

    " For cursor moving in insert mode(Not recommended)
    inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
    inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
    inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
    inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
    "" Or set this.
    "let g:neocomplete#enable_cursor_hold_i = 1
    " Or set this.
    "let g:neocomplete#enable_insert_char_pre = 1

    " AutoComplPop like behavior.
    " let g:neocomplete#enable_auto_select = 1

    " Shell like behavior(not recommended).
    "set completeopt+=longest
    "let g:neocomplete#enable_auto_select = 1
    "let g:neocomplete#disable_auto_complete = 1
    "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    autocmd FileType vue setlocal omnifunc=htmlcomplete#CompleteTags

    " Enable heavy omni completion.
    " if !exists('g:neocomplete#sources#omni#input_patterns')
    " let g:neocomplete#sources#omni#input_patterns = {}
    " endif
    "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

"}}}
"Valloric/YouCompleteMe {{{
elseif count(g:exvim_plug_groups , 'YouCompleteMe')
    let g:ycm_confirm_extra_conf=0   "设置加载py文件不提示
    "设置离开插入模式自动关闭预览窗口
    let g:ycm_autoclose_preview_window_after_insertion=1
    "设置选择预览数据过后自动关闭
    let g:ycm_autoclose_preview_window_after_completion =1
    if g:iswindows
        let g:ycm_python_binary_path="C:/Program Files/Python35/python.exe"
        let g:ycm_global_ycm_extra_conf = 'C:/Yvim/vimfiles/requirefile/windows/.ycm_extra_conf.py'
    else
        let g:ycm_python_binary_path="/usr/bin/python3.5"
        let g:ycm_global_ycm_extra_conf = '~/software/exvim1/vimfiles/requirefile/linux/.ycm_extra_conf.py'
    endif
    let g:ycm_filetype_whitelist = { 'c': 1 ,'cpp' : 1,'h':1,'javascript':1,'html':1,'htm':1,'python':1 }

    " YCM 集成 OmniCppComplete 补全引擎
    inoremap <leader>; <C-x><C-o>
    " 设置转到定义处的快捷键为ALT + G，
    "nmap <M-g> :YcmCompleter GoToDefinitionElseDeclaration <C-R>=expand("<cword>")<CR><CR>
    nnoremap <M-g> :YcmCompleter GoTo <CR>
    "命名模式下ycm映射到YcmCompleter
    "cmap ycm YcmCompleter
    autocmd FileType javascript nnoremap <M-F7> :YcmCompleter GoToReferences<cr>
    autocmd FileType javascript nnoremap <S-F6> :YcmCompleter RefactorRename<space>
    " 补全功能在注释中同样有效
    let g:ycm_complete_in_comments=1
    " 开启标签补全
    " let g:ycm_collect_identifiers_from_tags_files = 1
    " set tags+='e:\.symbs\cpp_src\tags' "C++标准库的tags
    " 从第一个键入字符就开始罗列匹配项
    let g:ycm_min_num_of_chars_for_completion=2
    " 离开插入模式后自动关闭预览窗口
    autocmd InsertLeave * if pumvisible() == 0|pclose|endif
    " 禁止缓存匹配项，每次都重新生成匹配项
    "let g:ycm_cache_omnifunc = 1
    " 语法关键字补全
    let g:ycm_seed_identifiers_with_syntax=1
    " 修改对C函数的补全快捷键，默认是CTRL + space，修改为ALT + ;
    let g:ycm_key_invoke_completion = '<M-;>'
    " 回车即选中当前项
    inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"
endif
"}}}


"'maralla/completor.vim' {{{
 if g:iswindows
        let g:completor_python_binary ="C:/Program Files/Python35/python.exe"
    else
        let g:ycm_python_binary_path="/usr/bin/python3.5"
  endif

inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
inoremap <expr> <cr> pumvisible() ? "\<C-y>\<cr>" : "\<cr>"
"}}}


"maksimr/vim-jsbeautify {{{
" or
autocmd FileType javascript noremap <buffer>  <leader>f :call JsBeautify()<cr>
" for json
autocmd FileType json noremap <buffer> <leader>f :call JsonBeautify()<cr>
" for html
autocmd FileType html noremap <buffer> <leader>f :call HtmlBeautify()<cr>
" for css or scss
autocmd FileType css noremap <buffer> <leader>f :call CSSBeautify()<cr>
autocmd FileType javascript vnoremap <buffer>  <leader>f :call RangeJsBeautify()<cr>
autocmd FileType json vnoremap <buffer> <leader>f :call RangeJsonBeautify()<cr>
autocmd FileType html vnoremap <buffer> <leader>f :call RangeHtmlBeautify()<cr>
autocmd FileType css vnoremap <buffer> <leader>f :call RangeCSSBeautify()<cr>
autocmd FileType vue vnoremap <buffer> <leader>fh :call RangeHtmlBeautify()<cr>
autocmd FileType vue vnoremap <buffer> <leader>fc :call RangeCSSBeautify()<cr>
autocmd FileType vue vnoremap <buffer> <leader>fj :call RangeJsBeautify()<cr>
"}}}

"skywind3000/asyncrun.vim {{{

augroup vimrc
    autocmd QuickFixCmdPost * botright copen 8
augroup END

let g:asyncrun_encs = 'gbk'
autocmd FileType python nnoremap <F9> :AsyncRun python3 %:p<cr>
if g:islinux
  autocmd FileType html nnoremap <F9> :AsyncRun firefox %<cr>
else
  autocmd FileType html nnoremap <F9> :AsyncRun D:\DevelopTool\ffdevelop\firefox.exe %<cr>
endif
nnoremap <c-F9> :AsyncStop <cr>
noremap <F10> :call asyncrun#quickfix_toggle(8)<cr>

"}}}

if g:islinux
    set guifont=Source\ Code\ Pro\ Bold\ 11
endif
"fix webpack-hot-reload not work in linux
set backupcopy=yes
